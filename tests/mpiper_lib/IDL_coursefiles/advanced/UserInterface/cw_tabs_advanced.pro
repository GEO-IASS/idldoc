;+
; Set properties of the cw_tabs compound widget.
;
; @keyword titles {in}{type=string array} names of the tabs
;-
pro cw_tabs_control::set, titles=titles
    compile_opt idl2, hidden

    widget_control, widget_info(self.tlb, /child), get_uvalue=pstate

    if (n_elements(titles) ne 0) then begin
        if ((*pstate).drop ne 0) then begin
            widget_control, (*pstate).drop, set_value=titles
        endif
    endif
end


;+
; Nothing to do.
;-
pro cw_tabs_control::cleanup
    compile_opt idl2, hidden

end


;+
; Store away the top-level base widget ID.
;-
function cw_tabs_control::init, tlb
    compile_opt idl2, hidden

    if (n_params() eq 0) then return, 0

    self.tlb = tlb
    return, 1
end


;+
; Define control object for cw_tabs.
;-
pro cw_tabs_control__define
    compile_opt idl2, hidden

    define = { cw_tabs_control, tlb:0 }
end


;+
; Event handler for the controls for the tab base.
;
; @private
; @returns 0 if the event was generated by the controls for the tab
;          base or the event if it was generated from widgets on the
;          tab base
; @param event {in}{type=structure} event structure from the
;        control_base buttons or droplist OR from the widgets on the
;         tabs
;-
function cw_tabs_event_func, event
    compile_opt idl2, hidden

    stash = widget_info(event.handler, /child)
    widget_control, stash, get_uvalue=pstate
    uname = widget_info(event.id, /uname)

    case uname of
    'cw_tabs_buttoncontrol' : begin
            widget_control, event.id, get_uvalue=index
            cw_tabs_set_value, event.handler, index
            return, 0
        end
    'cw_tabs_dropcontrol' : begin
            cw_tabs_set_value, event.handler, event.index
            return, 0
        end
    else : return, event
    endcase
end


;+
; Gets the index of the currently visible tab.  This routine should
; not be called directly; it should be called using:
; <code>widget_control, id, get_value=val</code>.
;
; @private
; @returns the index of the currently visible tab
; @param id {in}{type=widget ID} widget identifier of the cw_tabs
;-
function cw_tabs_get_value, id
    compile_opt idl2, hidden

    widget_control, widget_info(id, /child), get_uvalue=pstate

    return, (*pstate).current_tab_index
end


;+
; Change the currently visible tab.  This routine should not be
; called directly; it should be called using:
; <code>widget_control, id, set_value=val</code>.
;
; @private
; @param id {in}{type=widget ID} widget identifier of the cw_tabs
; @param index {in}{type=integer type} index of the tab to make
;        current
;-
pro cw_tabs_set_value, id, index
    compile_opt idl2, hidden

    widget_control, widget_info(id, /child), get_uvalue=pstate

    if ((index lt 0) or $
        (index gt (n_elements((*pstate).bases) - 1))) then $
        message, 'index out of bounds'

    old_index = (*pstate).current_tab_index
    widget_control, (*pstate).bases[old_index], map=0
    (*pstate).current_tab_index = index
    widget_control, (*pstate).bases[index], map=1
    if ((*pstate).drop ne 0) then $
        widget_control, (*pstate).drop, set_droplist_select=index
end


;+
; Cleanup state pointer.
;
; @param stash {in}{type=widget ID} widget identifier of the stash
;        widget whose uvalue contains the pointer to the state
;        structure
;-
pro cw_tabs_cleanup, stash
    compile_opt idl2, hidden

    widget_control, stash, get_uvalue=pstate
    obj_destroy, (*pstate).control
    ptr_free, pstate
end


;+
; Compound widget representing a tab base.  Useful for IDL versions
; before 5.6.
;
; @returns widget ID of the compound widget
; @param parent {in}{type=widget ID} widget identifier of the parent
;        widget base
; @keyword bases {out}{optional}{type=array of widget IDs} returns
;          the widget IDs of the tab bases; the number of IDs will be
;          the length of the titles keyword array
; @keyword buttons {in}{optional}{type=boolean}{default=false} set
;          to use push buttons to navigate the tabs instead of the
;          droplist
; @keyword control {out}{optional}{type=object ref} a object reference
;          to control the tabbase is passed back through this keyword
; @keyword titles {in}{type=string array} titles of the individual
;          bases
; @keyword uname {in}{type=string} uname for the compound widget
; @keyword uvalue {in}{type=any IDL variable} uvalue for the compound
;          widget
;-
function cw_tabs, parent, $
    bases=bases, $
    buttons=buttons, $
    control=control, $
    titles=titles, $
    uname=uname, $
    uvalue=uvalue

    compile_opt idl2
    on_error, 2

    if (n_elements(titles) eq 0) then $
        message, 'TITLES keyword must be given string array of titles'

    tlb = widget_base(parent, /column, /base_align_center, $
        event_func='cw_tabs_event_func', $
        func_get_value='cw_tabs_get_value', $
        pro_set_value='cw_tabs_set_value', $
        uname=uname, $
        uvalue=uvalue)

    control = arg_present(control) $
        ? obj_new('cw_tabs_control', tlb) $
        : obj_new()

    control_base = widget_base(tlb, /row)
    drop = 0
    if (keyword_set(buttons)) then $
        for i = 0, n_elements(titles) - 1 do $
            button = widget_button(control_base, value=titles[i], $
                uname='cw_tabs_buttoncontrol', uvalue=i) $
    else $
        drop = widget_droplist(control_base, value=titles, $
            uname='cw_tabs_dropcontrol', /align_center)

    ; Create the actual tab bases -- the trick is to put the bases
    ; on a grid base so they are on top of each other and then map
    ; the visible one, leaving the others unmapped
    grid = widget_base(tlb, frame=1)
    bases = lonarr(n_elements(titles))
    for i = 0, n_elements(titles) - 1 do begin
        bases[i] = widget_base(grid, /column, map=0)
    endfor

    widget_control, bases[0], map=1

    state = { $
        control:control, $
        drop:drop, $
        bases:bases, $
        current_tab_index:0 $
        }
    pstate = ptr_new(state, /no_copy)

    ; The uvalue of tlb is reserved for the user of the compound
    ; widget
    widget_control, widget_info(tlb, /child), $
        set_uvalue=pstate, $
        kill_notify='cw_tabs_cleanup'

    return, tlb
end
