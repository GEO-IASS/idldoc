;+
; The event handling routine for mesh_render.
;
; @param event {in}{type=structure} The event structure from xmanager
;-
pro mesh_render_event, event
    compile_opt idl2

    ; Retrieve the state structure from the top-level base & the uvalue of
    ; the widget that generated the event.
    widget_control, event.top, get_uvalue=pstate
    widget_control, event.id, get_uvalue=uval

    ; If a widget_kill_request was generated by clicking the system
    ; close button, execute the following code.
    if tag_names(event, /struct) eq 'WIDGET_KILL_REQUEST' then begin
        device, decomposed=(*pstate).odec
        if (*pstate).odec eq 0 then tvlct, (*pstate).colors
        ptr_free, (*pstate).v1, (*pstate).p1, pstate
        !p.t = identity(4)
        widget_control, event.top, /destroy
        return
    endif

end

;+
; The "do" routine for mesh_render.
;
; @param pstate {in}{type=pointer} The state pointer
;-
pro mesh_render_dodisplay, pstate
    compile_opt idl2

    wset, (*pstate).win_id
    set_shading, reject=0, /gouraud, light=[1,1,1]
    tvscl, polyshade(*(*pstate).v1, *(*pstate).p1, /t3d, /data)

end

;+
; An early form of mesh_render. Some event handling.
;
; @param v0 {in}{optional}{type=float or integer array} A vertex array
; @param p0 {in}{optional}{type=long array} The connectivity list for the
;       vertices
; @keyword no_block {in}{optional}{type=boolean} Set to force widget program
;       to be nonblocking. Default is to block command line.
; @author Mark Piper, 1999
; @history Revised 2002, mp
; @copyright RSI
;-
pro mesh_render2, v0, p0, no_block=no_block
    compile_opt idl2

    ; If no arguments are passed, then read in a sample data file.
    if n_params() ne 2 then begin
        file = filepath('knot.dat', subdir=['examples','demo','demodata'])
        restore, file, /verbose
        v0 = transpose([[x],[y],[z]])
        p0 = mesh
    endif

    ; Retrieve the current IDL color mode & color table, if necessary.
    device, get_decomposed=odec
    if odec eq 0 then begin
        tvlct, r, g, b, /get
        tek_color, 0, 8
    endif else r = (g = (b = 0))

    ; Get statistics on the input data.
    orig_size = size(v0)
    orig_verts = orig_size[2]
    orig_tri = mesh_validate(v0, p0, /remove_nan, /pack_vertices)
    orig_area = mesh_surfacearea(v0, p0)
    minv0 = min(v0, max=maxv0)

    ; Make the top-level base.
    wtop1 = widget_base(title='RSI Training - Polygonal Mesh Renderer', $
        /column, /base_align_center, tlb_frame_attr=1)

    ; Make a draw widget.
    device, get_screen_size=ss
    wdraw = widget_draw(wtop1, xsize=0.5*ss[0], ysize=0.5*ss[1])

    ; Make a set of panels for displaying info about the mesh data set.
    wbase1 = widget_base(wtop1, /row, space=25)
    wbase1a = widget_base(wbase1, /column, /frame)
    wvertslabel = widget_label(wbase1a, value='Vertices', $
        font='Helvetica*14*Bold')
    worigverts = cw_field(wbase1a, title='Original: ', $
        value=orig_verts, xsize=5, /noedit, font='Courier*14')
    wcurrverts = cw_field(wbase1a, title='Current:  ', $
        value=orig_verts, xsize=5, /noedit, uname='currverts', $
        font='Courier*14')
    wbase1b = widget_base(wbase1, /column, /frame)
    wtrilabel = widget_label(wbase1b, value='Triangles', $
        font='Helvetica*14*Bold')
    worigtri = cw_field(wbase1b, title='Original: ', $
        value=orig_tri, xsize=5, /noedit, font='Courier*14')
    wcurrtri = cw_field(wbase1b, title='Current:  ', $
        value=orig_tri, xsize=5, /noedit, uname='currtri', $
        font='Courier*14')
    wbase1c = widget_base(wbase1, /column, /frame)
    warealabel = widget_label(wbase1c, value='Surface Area', $
        font='Helvetica*14*Bold')
    worigarea = cw_field(wbase1c, title='Original: ', $
        value=orig_area, xsize=5, /noedit, font='Courier*14')
    wcurrarea = cw_field(wbase1c, title='Current:  ', $
        value=orig_area, xsize=5, /noedit, uname='currarea', $
        font='Courier*14')

    ; Make a pair of sliders to manipulate the mesh data.
    wbase2 = widget_base(wtop1, /row, space=5)
    wdecimate = widget_slider(wbase2, minimum=2, maximum=100, $
        value=100, title='Decimate (%)', uvalue='decimate', $
        font='Times*18')
    wsmooth = widget_slider(wbase2, minimum=1, maximum=50, $
        value=10, title='Smooth (iterations)', uvalue='smooth', $
        font='Times*18')

    ; Realize the widget hierarchy.
    widget_control, wtop1, /realize

    ; Get the window index from the draw widget.
    widget_control, wdraw, get_value=win_id

    ; Set the top-level base to signal when the system close button
    ; is clicked.
    widget_control, wtop1, /tlb_kill_request_events

    ; Create a state structure and load it into the top-level bases.
    state = { $
        v0          : v0, $
        p0          : p0, $
        orig_verts  : orig_verts, $
        orig_tri    : orig_tri, $
        orig_area   : orig_area, $
        v1          : ptr_new(v0), $
        p1          : ptr_new(p0), $
        curr_verts  : 0, $
        curr_tri    : 0, $
        curr_area   : 0.0, $
        win_id      : win_id, $
        odec        : odec, $
        colors      : [[r],[g],[b]] $
        }
    pstate = ptr_new(state, /no_copy)
    widget_control, wtop1, set_uvalue=pstate

    ; Set up a coordinate system and display the isosurface.
    scale3, xrange=[-maxv0,maxv0], yrange=[-maxv0,maxv0], $
        zrange=[-maxv0,maxv0]
    mesh_render_dodisplay, pstate

    ; Call XMANAGER.
    xmanager, 'mesh_render', wtop1, $
        no_block=keyword_set(no_block)

end
