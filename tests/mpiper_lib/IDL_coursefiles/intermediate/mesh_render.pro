;=========================================================================
;+
; The event handling routine for mesh_render.
;
; @param event {in}{type=structure} The event structure from xmanager
;-
pro mesh_render_event, event
    compile_opt idl2

    ; Retrieve the state structure from the top-level base & the uvalue of
    ; the widget that generated the event.
    widget_control, event.top, get_uvalue=pstate
    widget_control, event.id, get_uvalue=uval

    ; If a widget_kill_request was generated by clicking the system
    ; close button, execute the following code.
    if tag_names(event, /struct) eq 'WIDGET_KILL_REQUEST' then begin
        device, decomposed=(*pstate).odec
        if (*pstate).odec eq 0 then tvlct, (*pstate).colors
        ptr_free, (*pstate).v1, (*pstate).p1, pstate
        !p.t = identity(4)
        widget_control, event.top, /destroy
        return
    endif

    ; Event code for the widget that generated the event.
    case uval of

    'decimate': begin

        ; Turn on the hourglass.
        widget_control, hourglass=1

        ; Perform decimation. This may be costly! Afterward, update the
        ; state pointer.
        curr_tri = mesh_decimate((*pstate).v0, (*pstate).p0, p1, $
            percent_vertices=event.value, vertices=v1)
        *(*pstate).v1 = v1
        *(*pstate).p1 = p1

        ; Display the resulting mesh as an image.
        mesh_render_dodisplay, pstate

        ; Update the stats for the mesh data set and display them in
        ; the panels on the application interface.
        curr_size = size(v1)
        curr_verts = curr_size[2]
        widget_control, widget_info(event.top, $
            find_by_uname='currverts'), set_value=curr_verts
        widget_control, widget_info(event.top, $
            find_by_uname='currtri'), set_value=curr_tri
        curr_area = mesh_surfacearea(v1, p1)
        widget_control, widget_info(event.top, $
            find_by_uname='currarea'), set_value=curr_area

        ; Turn off the hourglass.
        widget_control, hourglass=0

        end

    'smooth': begin

        ; Turn on the hourglass.
        widget_control, hourglass=1

        ; Perform smoothing, then update the state pointer.
        v1 = mesh_smooth(*(*pstate).v1, *(*pstate).p1, $
            iterations=event.value, /fixed_edge_vertices)
        *(*pstate).v1 = v1

        ; Display the resulting mesh as an image.
        mesh_render_dodisplay, pstate

        ; Update the stats for the mesh data set and display them in
        ; the panels on the application interface.
        curr_size = size(v1)
        curr_verts = curr_size[2]
        widget_control, widget_info(event.top, $
            find_by_uname='currverts'), set_value=curr_verts
        curr_area = mesh_surfacearea(v1, *(*pstate).p1)
        widget_control, widget_info(event.top, $
            find_by_uname='currarea'), set_value=curr_area

        ; Turn off the hourglass.
        widget_control, hourglass=0

        end

    'orient': begin

        ; Display the mesh.
        mesh_render_dodisplay, pstate

        end
    endcase

end


;=========================================================================
;+
; The "do" routine for mesh_render.
;
; @param pstate {in}{type=pointer} The state pointer
;-
pro mesh_render_dodisplay, pstate
    compile_opt idl2

    wset, (*pstate).win_id
    set_shading, reject=0, /gouraud, light=[1,1,1]
    tvscl, polyshade(*(*pstate).v1, *(*pstate).p1, /t3d, /data)

end


;=========================================================================
;+
; <center><img src="mesh_render.png" alt="mesh_render" /></center><br>
;
; This widget program demonstrates the use of polygonal meshes
; for displaying three-dimensional data sets. It uses several
; built-in IDL mesh routines.
; Other concepts: TLB_KILL_REQUEST_EVENTS, text fonts in
;   widgets, include file, CATCH, COMPILE_OPT statement,
;   HOURGLASS keyword, WIDGET_INFO, SCALE3, MESH_VALIDATE
;   MESH_NUMTRIANGLES function, widget spacing and alignment,
;   CW_FIELD, POLYSHADE, MESH_DECIMATE, MESH_SMOOTH,
;   ISOSURFACE, MESH_SURFACEAREA, TLB_FRAME_ATTR, SET_SHADING,
;   use of multiple top-level bases.
;
; @param v0 {in}{optional}{type=float or integer array} A vertex array
; @param p0 {in}{optional}{type=long array} The connectivity list for the
;       vertices
; @keyword no_block {in}{optional}{type=boolean} Set to force widget
;       program to be nonblocking. Default is to block command line.
; @author Mark Piper, 1999
; @history Revised 2002, mp
; @copyright RSI
;
; @examples
;   <pre>
;   IDL> restore, filepath('clouds3d.dat', subdir=['examples', $ <br>
;   IDL>    'data']), /verbose <br>
;   IDL> isosurface, clouds, 0.1, v, p <br>
;   IDL> mesh_render, v, p <br>
;   <p>
;   IDL> file = filepath('car.smf', subdir='training') <br>
;   IDL> read_smf_file, file, v, p <br>
;   IDL> mesh_render, v, p <br>
;   <p>
;   IDL> file = filepath('x29.txt', subdir='training') <br>
;   IDL> read_noff, file, v, p <br>
;   IDL> mesh_render, v, p <br>
;   </pre>
;-
pro mesh_render, v0, p0, no_block=no_block
    compile_opt idl2

    ; If no arguments are passed, then read in a sample data file.
    if n_params() ne 2 then begin
        file = filepath('knot.dat', subdir=['examples','demo','demodata'])
        restore, file, /verbose
        v0 = transpose([[x],[y],[z]])
        p0 = mesh
    endif

    ; Retrieve the current IDL color mode & color table, if necessary.
    device, get_decomposed=odec
    if odec eq 0 then begin
        tvlct, r, g, b, /get
        tek_color, 0, 8
    endif else r = (g = (b = 0))

    ; Get statistics on the input data.
    orig_size = size(v0)
    orig_verts = orig_size[2]
    orig_tri = mesh_validate(v0, p0, /remove_nan, /pack_vertices)
    orig_area = mesh_surfacearea(v0, p0)
    minv0 = min(v0, max=maxv0)

    ; Make the top-level base.
    wtop1 = widget_base(title='RSI Training - Polygonal Mesh Renderer', $
        /column, /base_align_center, tlb_frame_attr=1)

    ; Make a draw widget.
    device, get_screen_size=ss
    wdraw = widget_draw(wtop1, xsize=0.5*ss[0], ysize=0.5*ss[1])

    ; Make a set of panels for displaying info about the mesh data set.
    wbase1 = widget_base(wtop1, /row, space=25)
    wbase1a = widget_base(wbase1, /column, /frame)
    wvertslabel = widget_label(wbase1a, value='Vertices', $
        font='Helvetica*14*Bold')
    worigverts = cw_field(wbase1a, title='Original: ', $
        value=orig_verts, xsize=5, /noedit, font='Courier*14')
    wcurrverts = cw_field(wbase1a, title='Current:  ', $
        value=orig_verts, xsize=5, /noedit, uname='currverts', $
        font='Courier*14')
    wbase1b = widget_base(wbase1, /column, /frame)
    wtrilabel = widget_label(wbase1b, value='Triangles', $
        font='Helvetica*14*Bold')
    worigtri = cw_field(wbase1b, title='Original: ', $
        value=orig_tri, xsize=5, /noedit, font='Courier*14')
    wcurrtri = cw_field(wbase1b, title='Current:  ', $
        value=orig_tri, xsize=5, /noedit, uname='currtri', $
        font='Courier*14')
    wbase1c = widget_base(wbase1, /column, /frame)
    warealabel = widget_label(wbase1c, value='Surface Area', $
        font='Helvetica*14*Bold')
    worigarea = cw_field(wbase1c, title='Original: ', $
        value=orig_area, xsize=5, /noedit, font='Courier*14')
    wcurrarea = cw_field(wbase1c, title='Current:  ', $
        value=orig_area, xsize=5, /noedit, uname='currarea', $
        font='Courier*14')

    ; Make a pair of sliders to manipulate the mesh data.
    wbase2 = widget_base(wtop1, /row, space=5)
    wdecimate = widget_slider(wbase2, minimum=2, maximum=100, $
        value=100, title='Decimate (%)', uvalue='decimate', $
        font='Times*18')
    wsmooth = widget_slider(wbase2, minimum=1, maximum=50, $
        value=10, title='Smooth (iterations)', uvalue='smooth', $
        font='Times*18')

    ; Make a floating top-level base with a positioner inside.
    wtop2 = widget_base(group_leader=wtop1, xoffset=0.5*ss[0]+15, $
        tlb_frame_attr=1, /floating, title='Orientation')
    worient = cw_orient(wtop2, uvalue='orient')

    ; Realize the widget hierarchy.
    widget_control, wtop1, /realize
    widget_control, wtop2, /realize

    ; Get the window index from the draw widget.
    widget_control, wdraw, get_value=win_id

    ; Set the top-level base to signal when the system close button
    ; is clicked.
    widget_control, wtop1, /tlb_kill_request_events

    ; Create a state structure and load it into the top-level bases.
    state = { $
        v0          : v0, $
        p0          : p0, $
        orig_verts  : orig_verts, $
        orig_tri    : orig_tri, $
        orig_area   : orig_area, $
        v1          : ptr_new(v0), $
        p1          : ptr_new(p0), $
        curr_verts  : 0, $
        curr_tri    : 0, $
        curr_area   : 0.0, $
        win_id      : win_id, $
        odec        : odec, $
        colors      : [[r],[g],[b]] $
        }
    pstate = ptr_new(state, /no_copy)
    widget_control, wtop1, set_uvalue=pstate
    widget_control, wtop2, set_uvalue=pstate

    ; Set up a coordinate system and display the isosurface.
    scale3, xrange=[-maxv0,maxv0], yrange=[-maxv0,maxv0], $
        zrange=[-maxv0,maxv0]
    mesh_render_dodisplay, pstate

    ; Call XMANAGER.
    xmanager, '', wtop2, $
        /just_reg, $
        no_block=keyword_set(no_block), $
        event_handler='mesh_render_event'
    xmanager, 'mesh_render', wtop1, $
        no_block=keyword_set(no_block)

end
